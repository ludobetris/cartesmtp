<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Carte Mapbox avec Gestion des Déneigements</title>
    <!-- Inclure les feuilles de style de Mapbox GL JS et Mapbox GL Draw -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.2/mapbox-gl-draw.css" rel="stylesheet">
    <style>
        /* Styles pour la page et la carte */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        /* Style pour les boutons */
        #toggleView, #centerOnTracker, #validateZone, #trackerSelect, #toggleTrace {
            position: absolute;
            z-index: 1;
            padding: 10px;
            background: white;
            border: none;
            cursor: pointer;
        }
        #toggleView {
            top: 10px;
            left: 10px;
            margin-right: 5px;
        }
        #centerOnTracker {
            top: 10px;
            left: 110px;
            margin-right: 5px;
        }
        #trackerSelect {
            top: 10px;
            left: 210px;
        }
        #validateZone {
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: green;
            color: white;
        }
        #toggleTrace {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: green;
            color: white;
        }
        /* Style pour les marqueurs */
        .custom-marker {
            background-image: url('https://img.icons8.com/ios-filled/50/000000/car--v1.png');
            background-size: cover;
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }
        .marker-label, .polygon-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
        }
        /* Style pour le curseur en mode sélection */
        .mapboxgl-canvas.cursor-pointer {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <button id="toggleView">3D/2D</button>
    <button id="centerOnTracker">Centrer</button>
    <select id="trackerSelect">
        <option value="">Sélectionnez votre véhicule</option>
    </select>
    <button id="validateZone">Valider la zone</button>
    <button id="toggleTrace">START</button>
    <!-- Inclure les scripts de Mapbox GL JS, Mapbox GL Draw et Turf.js -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.2/mapbox-gl-draw.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script>
        // Remplacez 'VOTRE_ACCESS_TOKEN_MAPBOX' par votre propre token Mapbox
        mapboxgl.accessToken = 'pk.eyJ1IjoibHVkb2JldHJpcyIsImEiOiJjbTNhM3ljY3oxMXFxMmxzZmQwdm5tcWhpIn0.E22bDYSixD27MweKxToXyA';

        // Initialiser la carte
        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: [2.3522, 48.8566], // Coordonnées de Paris par défaut
            zoom: 12,
            pitch: 0, // Vue 2D par défaut
            bearing: 0,
            antialias: true // Nécessaire pour les bâtiments 3D
        });

        // Ajouter les contrôles de navigation
        map.addControl(new mapboxgl.NavigationControl());

        // Initialiser Mapbox Draw sans modifier les styles par défaut
        var draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
                polygon: true,
                line_string: true,
                trash: true
            }
        });
        map.addControl(draw);

        // Variables globales
        var trackerMarkers = {}; // Dictionnaire des marqueurs de trackers
        var trackerTraces = {}; // Dictionnaire des traces de trackers
        var trackersData = []; // Liste des trackers disponibles
        var selectedTrackerId = null; // ID du tracker sélectionné
        var isTraceActive = false; // Indique si l'enregistrement de la trace est actif
        var lastPositions = {}; // Dernières positions des trackers pour l'interpolation
        var lastUpdateTime = {}; // Temps de la dernière mise à jour pour chaque tracker

        // Fonction pour mettre à jour la source des polygones
        function updatePolygons() {
            var data = draw.getAll();
            var polygons = {
                type: 'FeatureCollection',
                features: data.features.filter(function(feature) {
                    return feature.geometry.type === 'Polygon';
                })
            };
            map.getSource('draw-polygons').setData(polygons);
            addPolygonLabels(); // Mettre à jour les étiquettes
        }

        // Fonction pour mettre à jour la source des lignes
        function updateLineStrings() {
            var data = draw.getAll();
            var lines = {
                type: 'FeatureCollection',
                features: data.features.filter(function(feature) {
                    return feature.geometry.type === 'LineString';
                })
            };
            map.getSource('draw-lines').setData(lines);
        }

        // Charger les données des trackers au chargement de la carte
        map.on('load', function() {
            // Source pour les polygones
            map.addSource('draw-polygons', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            // Couche pour le remplissage des polygones
            map.addLayer({
                id: 'draw-polygon-fill',
                type: 'fill',
                source: 'draw-polygons',
                layout: {},
                paint: {
                    'fill-color': [
                        'case',
                        ['boolean', ['get', 'user_isCleared'], false],
                        '#00ff00', // Vert si validé
                        '#ff0000'  // Rouge si non validé
                    ],
                    'fill-opacity': 0.5
                }
            });

            // Couche pour les contours des polygones
            map.addLayer({
                id: 'draw-polygon-stroke',
                type: 'line',
                source: 'draw-polygons',
                layout: {},
                paint: {
                    'line-color': '#000000',
                    'line-width': 2
                }
            });

            // Source pour les lignes
            map.addSource('draw-lines', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            // Couche pour les lignes
            map.addLayer({
                id: 'draw-line',
                type: 'line',
                source: 'draw-lines',
                layout: {
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                paint: {
                    'line-color': '#0000ff', // Bleu
                    'line-width': 4 // Plus épais
                }
            });

            // Événements pour mettre à jour les sources lors des modifications
            map.on('draw.create', function() {
                updatePolygons();
                updateLineStrings();
            });
            map.on('draw.update', function() {
                updatePolygons();
                updateLineStrings();
            });
            map.on('draw.delete', function() {
                updatePolygons();
                updateLineStrings();
            });

            // Charger les données des trackers
            getTrackersData();
            // Rafraîchir les données toutes les 3 secondes
            setInterval(getTrackersData, 3000);

            // Ajouter les bâtiments 3D
            map.addLayer({
                'id': '3d-buildings',
                'source': 'composite',
                'source-layer': 'building',
                'filter': ['==', 'extrude', 'true'],
                'type': 'fill-extrusion',
                'minzoom': 15,
                'paint': {
                    'fill-extrusion-color': '#aaa',
                    'fill-extrusion-height': [
                        'interpolate', ['linear'], ['zoom'],
                        15, 0,
                        15.05, ['get', 'height']
                    ],
                    'fill-extrusion-base': [
                        'interpolate', ['linear'], ['zoom'],
                        15, 0,
                        15.05, ['get', 'min_height']
                    ],
                    'fill-extrusion-opacity': 0.6
                },
                'layout': {
                    'visibility': 'none' // Masquer par défaut
                }
            });
        });

        // Gestion du bouton pour centrer sur le tracker sélectionné
        document.getElementById('centerOnTracker').addEventListener('click', function() {
            if (selectedTrackerId && trackerMarkers[selectedTrackerId]) {
                const marker = trackerMarkers[selectedTrackerId];
                const coords = marker.getLngLat();
                const heading = marker.heading || 0;
                map.flyTo({
                    center: coords,
                    zoom: 19, // Augmenté pour plus de zoom
                    pitch: 60,
                    bearing: -heading // Orientation dans le sens du déplacement
                });
            } else {
                alert("Aucun tracker sélectionné ou position inconnue.");
            }
        });

        // Gestion du bouton de bascule de vue 2D/3D
        document.getElementById('toggleView').addEventListener('click', function() {
            const currentPitch = map.getPitch();
            if (currentPitch === 0) {
                // Passer en vue 3D
                map.easeTo({ pitch: 60, duration: 1000 });
                map.setLayoutProperty('3d-buildings', 'visibility', 'visible');
            } else {
                // Passer en vue 2D
                map.easeTo({ pitch: 0, bearing: 0, duration: 1000 });
                map.setLayoutProperty('3d-buildings', 'visibility', 'none');
            }
        });

        // Gestion du bouton "Valider la zone"
        document.getElementById('validateZone').addEventListener('click', function() {
            const selectedFeatures = draw.getSelected();
            if (selectedFeatures.features.length > 0) {
                const selectedPolygonId = selectedFeatures.features[0].id;
                const feature = draw.get(selectedPolygonId);
                const isCleared = feature.properties.user_isCleared || false;
                draw.setFeatureProperty(selectedPolygonId, 'user_isCleared', !isCleared);

                // Mettre à jour les polygones pour refléter les changements
                updatePolygons();
            } else {
                alert('Aucun polygone sélectionné.');
            }
        });

        // Gestion du bouton START/STOP pour la trace
        document.getElementById('toggleTrace').addEventListener('click', function() {
            isTraceActive = !isTraceActive;
            const button = document.getElementById('toggleTrace');
            if (isTraceActive) {
                button.textContent = 'STOP';
                button.style.backgroundColor = 'red';
                // Réinitialiser la trace du tracker sélectionné
                if (selectedTrackerId) {
                    trackerTraces[selectedTrackerId] = [];
                    removeTrackerTrace(selectedTrackerId);
                }
            } else {
                button.textContent = 'START';
                button.style.backgroundColor = 'green';
            }
        });

        // Ajouter un événement pour nommer les polygones après leur création
        map.on('draw.create', function(e) {
            const feature = e.features[0];
            const id = feature.id;
            if (feature.geometry.type === 'Polygon') {
                const name = prompt('Entrez un nom pour ce polygone :');
                if (name) {
                    draw.setFeatureProperty(id, 'name', name);
                }
            }

            // Mettre à jour les polygones et les étiquettes
            updatePolygons();
            updateLineStrings();
        });

        // Fonction pour ajouter des étiquettes aux polygones
        function addPolygonLabels() {
            // Supprimer l'ancienne couche et source
            if (map.getLayer('polygon-labels')) {
                map.removeLayer('polygon-labels');
            }
            if (map.getSource('polygon-labels')) {
                map.removeSource('polygon-labels');
            }

            // Récupérer tous les polygones
            const data = draw.getAll();
            const polygons = data.features.filter(f => f.geometry.type === 'Polygon');

            if (polygons.length > 0) {
                const labels = polygons.map(polygon => {
                    const center = turf.centerOfMass(polygon).geometry.coordinates;
                    return {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': center
                        },
                        'properties': {
                            'name': polygon.properties.name || 'Zone'
                        }
                    };
                });

                // Ajouter la source et la couche pour les étiquettes
                map.addSource('polygon-labels', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': labels
                    }
                });

                map.addLayer({
                    'id': 'polygon-labels',
                    'type': 'symbol',
                    'source': 'polygon-labels',
                    'layout': {
                        'text-field': ['get', 'name'],
                        'text-font': ['Open Sans Bold'],
                        'text-size': 12,
                        'text-offset': [0, 0],
                        'text-anchor': 'center'
                    },
                    'paint': {
                        'text-color': '#ffffff',
                        'text-halo-color': '#000000',
                        'text-halo-width': 1
                    }
                });
            }
        }

        // Afficher les bâtiments en 3D lorsqu'on passe en vue 3D
        map.on('pitch', function() {
            const currentPitch = map.getPitch();
            if (currentPitch > 0) {
                map.setLayoutProperty('3d-buildings', 'visibility', 'visible');
            } else {
                map.setLayoutProperty('3d-buildings', 'visibility', 'none');
            }
        });

        // Gestion du changement de tracker sélectionné
        document.getElementById('trackerSelect').addEventListener('change', function() {
            selectedTrackerId = parseInt(this.value);
            // Réinitialiser la trace du tracker sélectionné
            if (isTraceActive && selectedTrackerId) {
                trackerTraces[selectedTrackerId] = [];
                removeTrackerTrace(selectedTrackerId);
            }
        });

        // Fonction pour récupérer les données des trackers
        async function getTrackersData() {
            try {
                // Remplacez 'VOTRE_EMAIL' et 'VOTRE_MOT_DE_PASSE' par vos identifiants Traccar
                const credentials = btoa('l.betrisey@solioz-merkli.ch:Clapton/1254');
                const positionsResponse = await fetch('https://demo2.traccar.org/api/positions', {
                    method: 'GET',
                    headers: {
                        'Authorization': 'Basic ' + credentials,
                        'Content-Type': 'application/json'
                    }
                });
                const devicesResponse = await fetch('https://demo2.traccar.org/api/devices', {
                    method: 'GET',
                    headers: {
                        'Authorization': 'Basic ' + credentials,
                        'Content-Type': 'application/json'
                    }
                });
                const positionsData = await positionsResponse.json();
                const devicesData = await devicesResponse.json();

                // Traiter les données et afficher les trackers
                displayTrackers(positionsData, devicesData);
            } catch (error) {
                console.error('Erreur lors de la récupération des données des trackers:', error);
            }
        }

        // Fonction pour afficher les trackers sur la carte
        function displayTrackers(positions, devices) {
            // Mettre à jour la liste des trackers
            trackersData = devices;

            // Mettre à jour le menu déroulant si nécessaire
            updateTrackerSelect();

            positions.forEach(position => {
                const device = devices.find(d => d.id === position.deviceId);
                if (device) {
                    const coords = [position.longitude, position.latitude];
                    const deviceId = device.id;

                    // Enregistrer le temps de mise à jour
                    const now = Date.now();
                    lastUpdateTime[deviceId] = now;

                    // Initialiser la position précédente
                    if (!lastPositions[deviceId]) {
                        lastPositions[deviceId] = coords;
                    }

                    // Mettre à jour le marqueur du tracker avec interpolation
                    if (trackerMarkers[deviceId]) {
                        animateMarker(deviceId, lastPositions[deviceId], coords, 3000);
                    } else {
                        const el = document.createElement('div');
                        el.className = 'custom-marker';

                        const label = document.createElement('div');
                        label.className = 'marker-label';
                        label.textContent = device.name;
                        el.appendChild(label);

                        const marker = new mapboxgl.Marker(el)
                            .setLngLat(coords)
                            .addTo(map);

                        trackerMarkers[deviceId] = marker;
                    }

                    // Mettre à jour la position précédente
                    lastPositions[deviceId] = coords;

                    // Enregistrer la position pour la trace si active
                    if (isTraceActive && selectedTrackerId === deviceId) {
                        if (!trackerTraces[deviceId]) {
                            trackerTraces[deviceId] = [];
                        }

                        // Vérifier la distance avec le dernier point
                        const lastTraceCoords = trackerTraces[deviceId][trackerTraces[deviceId].length - 1];
                        const distance = lastTraceCoords ? turf.distance(turf.point(lastTraceCoords), turf.point(coords)) * 1000 : Infinity;

                        // Vérifier le temps écoulé depuis le dernier point
                        const timeSinceLastPoint = lastTraceCoords ? now - lastUpdateTime[deviceId] : Infinity;

                        if (distance > 10 || timeSinceLastPoint > 15 * 60 * 1000) {
                            trackerTraces[deviceId].push(coords);
                            // Mettre à jour la trace du tracker
                            updateTrackerTrace(deviceId);
                        }
                    }

                    // Enregistrer le cap pour l'orientation
                    trackerMarkers[deviceId].heading = position.course || 0;
                }
            });
        }

        // Fonction pour animer le marqueur entre deux positions
        function animateMarker(deviceId, fromCoords, toCoords, duration) {
            const marker = trackerMarkers[deviceId];
            const start = performance.now();

            function animate(time) {
                const elapsed = time - start;
                const t = Math.min(elapsed / duration, 1);
                const interpolatedCoords = [
                    fromCoords[0] + (toCoords[0] - fromCoords[0]) * t,
                    fromCoords[1] + (toCoords[1] - fromCoords[1]) * t
                ];
                marker.setLngLat(interpolatedCoords);

                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            requestAnimationFrame(animate);
        }

        // Fonction pour mettre à jour la trace d'un tracker
        function updateTrackerTrace(deviceId) {
            const traceId = 'trace-' + deviceId;
            const coordinates = trackerTraces[deviceId];

            if (map.getSource(traceId)) {
                map.getSource(traceId).setData({
                    'type': 'Feature',
                    'geometry': {
                        'type': 'LineString',
                        'coordinates': coordinates
                    }
                });
            } else {
                map.addLayer({
                    'id': traceId,
                    'type': 'line',
                    'source': {
                        'type': 'geojson',
                        'data': {
                            'type': 'Feature',
                            'geometry': {
                                'type': 'LineString',
                                'coordinates': coordinates
                            }
                        }
                    },
                    'layout': {
                        'line-cap': 'round',
                        'line-join': 'round'
                    },
                    'paint': {
                        'line-color': '#00ff00',
                        'line-width': 8
                    }
                });
            }
        }

        // Fonction pour supprimer la trace d'un tracker
        function removeTrackerTrace(deviceId) {
            const traceId = 'trace-' + deviceId;
            if (map.getLayer(traceId)) {
                map.removeLayer(traceId);
            }
            if (map.getSource(traceId)) {
                map.removeSource(traceId);
            }
        }

        // Fonction pour mettre à jour le menu déroulant des trackers
        function updateTrackerSelect() {
            const select = document.getElementById('trackerSelect');
            // Vider le menu déroulant
            while (select.options.length > 1) {
                select.remove(1);
            }

            trackersData.forEach(tracker => {
                const option = document.createElement('option');
                option.value = tracker.id;
                option.textContent = tracker.name;
                select.appendChild(option);
            });
        }

    </script>
</body>
</html>
